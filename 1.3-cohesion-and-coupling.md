# Cohesion, Coupling and Change

## Cohesion
Cohesion is **how focused a class is**. When we look at a class, we want to ask ourselves "does this class have ONE clear job?"

You should be able to say:
"This class handles _______"
and the blank is only ONE thing.

For example, "this class handles database actions".

> Links to encapsulation (OOP), and single-responsibility (SOLID)
> Cohesion affects INSIDE a class.

### Low Cohesion ❌
When a class has low cohesion, it means that it is **unfocused**, with methods that do too many different things.
We want to avoid low cohesion.

```csharp
public class Utility
{
	public void SaveToFile(string data) { /* ... */ }
	public void SendEmail(string message) { /* ... */ }
	public void CalculateSalary() { /* ... */ }
}
```

### High Cohesion ✅
When a class has high cohesion, it means that it is **focused**, meaning that the class is only responsible for one job and the methods withing the class support that. We want our class to have high cohesion.

```csharp
public class SalaryCalculator
{
	public decimal CalculateSalary(Employee employee) { /* ... */ }
}

public class FileActions
{
    public void SaveToFile(string data) { /* ... */ }s
}
```
## Coupling
Coupling is **how tightly two pieces of code are connected**. When we look at how different class interact, we want to ask "how dependant are these two classes on one another?".

> Links to abstraction (OOP), interface segregation (SOLID) and dependency inversion (SOLID).
> Coupling affects the relationship between classes.

### High Coupling ❌
When two classes have high coupling aka **tightly coupled**, it means that they are very tightly glued together and making changes to one could possibly break another. We want to avoid high/tight coupling.

```csharp
public class ReportGenerator
{
	private DataFetcher fetcher = new DataFetcher(); // created inside class, so it cannot be mocked.
	public void Generate()
	{
		var data = fetcher.Fetch();
		// Generate report
	}
}

public class DataFetcher
{
	public string Fetch() { return "data"; }
}
```

### Low Coupling ✅
When two classes have low coupling aka **loosely coupled**, it means that they are loosely glued together. This means that making changes to one will not break the other. This also means that they are easy to test, scalable and flexible.

Low/loose coupling is achieved through **interfaces** and **dependency injection**.

```csharp
public interface IDataFetcher
{
	string Fetch();
}

public class DataFetcher : IDataFetcher
{
	public string Fetch() { return "data"; }
}

public class ReportGenerator
{
	private readonly IDataFetcher fetcher;
	public ReportGenerator(IDataFetcher fetcher) // Injected through DI, can now be mocked during tests.
	{
		this.fetcher = fetcher;
	}
	public void Generate()
	{
		var data = fetcher.Fetch();
		// Generate report
	}
}
```
## Change
When we work on a project and write code, we want to ask ourselves, **when something changes, how painful is it?**

Good Design - makes change easier
Bad Design - makes change scarier and harder

We try to implement high cohesion and low coupling to ensure that making changes in a project is an easy process.

> When we consider change, we are thinking about the whole project.