# SOLID Principles
SOLID stands for:
- **S** ingle-Responsibility
- **O** pen-Closed
- **L** iskov Substitution
- **I** nterface Segregation
- **D** ependency Inversion

These are the 5 class design principles of OOP. They apply to most software entities, such as classes, modules, and functions.

## Single-Responsibility
This principle outlines that classes should only have one reason to change. Another way to say this is **classes should only have one job**. 
>Single-Responsibility can be tied into **Encapsulation**.

#### Example: Violates Single Responsibility
```csharp
public class Report {
	public string Content { get; set; }
	public Report(string content) {
		Content = content;
	}
	public void SaveToFile(string filename) {
		System.IO.File.WriteAllText(filename, Content);
	}
}
```
*This class handles both report data and file saving, so it has more than one reason to change.*

#### Example: Follows Single Responsibility
```csharp
public class Report {
	public string Content { get; set; }
	public Report(string content) {
		Content = content;
	}
}

public class ReportSaver {
	public void SaveToFile(Report report, string filename) {
		System.IO.File.WriteAllText(filename, report.Content);
	}
}
```
*Now, `Report` only handles data, and `ReportSaver` handles saving, so each class has a single responsibility.*

## Open-Closed
This principle states that classes should be open for extension, and closed for modification. Another way to say this is that **a class should be extendable without modifying existing code**. This is because modifying existing code can break working behaviour or anything dependant on the class.

> Open-Closed can be tied to **Abstraction**.

#### Example: Violates Open-Closed Principle
```csharp
public class AreaCalculator {
	public double Area(object shape) {
		if (shape is Rectangle rect) {
			return rect.Width * rect.Height;
		} else if (shape is Circle circle) {
			return Math.PI * circle.Radius * circle.Radius;
		}
		// If a new shape is added, this method must be modified
		throw new ArgumentException("Unknown shape");
	}
}
public class Rectangle {
	public double Width { get; set; }
	public double Height { get; set; }
}
public class Circle {
	public double Radius { get; set; }
}
```
*Adding new shapes requires modifying the AreaCalculator, violating the Open-Closed Principle.*

#### Example: Follows Open-Closed Principle
```csharp
public interface IShape {
	double Area();
}
public class Rectangle : IShape {
	public double Width { get; set; }
	public double Height { get; set; }
	public double Area() => Width * Height;
}
public class Circle : IShape {
	public double Radius { get; set; }
	public double Area() => Math.PI * Radius * Radius;
}
public class AreaCalculator {
	public double Area(IShape shape) {
		return shape.Area();
	}
}
```
*New shapes can be added by implementing IShape, without modifying AreaCalculator.*