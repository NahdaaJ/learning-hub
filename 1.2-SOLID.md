# SOLID Principles

SOLID stands for:
- **S** ingle Responsibility
- **O** pen Closed
- **L** iskov Substitution
- **I** nterface Segregation
- **D** ependency Inversion

These are the five class design principles of OOP. They apply to most software entities, such as classes, modules, and functions.

## SingleResponsibility Principle
This principle states that classes should only have one reason to change. Another way to say this is **classes should only have one job**. 
>Single Responsibility can be tied to **Encapsulation**.

### Example: Violates Single Responsibility
```csharp
public class Report {
	public string Content { get; set; }
	public Report(string content) {
		Content = content;
	}
	public void SaveToFile(string filename) {
		System.IO.File.WriteAllText(filename, Content);
	}
}
```
*This class handles both report data and file saving, so it has more than one reason to change.*

### Example: Follows Single Responsibility
```csharp
public class Report {
	public string Content { get; set; }
	public Report(string content) {
		Content = content;
	}
}

public class ReportSaver {
	public void SaveToFile(Report report, string filename) {
		System.IO.File.WriteAllText(filename, report.Content);
	}
}
```
*Now, `Report` only handles data, and `ReportSaver` handles saving, so each class has a single responsibility.*

## Open-Closed Principle
This principle states that classes should be open for extension, and closed for modification. Another way to say this is that **a class should be extendable without modifying existing code**. This is because modifying existing code can break working behaviour or anything dependent on the class.

> Open-Closed can be tied to **Abstraction**.

### Example: Violates Open-Closed Principle
```csharp
public class AreaCalculator {
	public double Area(object shape) {
		if (shape is Rectangle rect) {
			return rect.Width * rect.Height;
		} else if (shape is Circle circle) {
			return Math.PI * circle.Radius * circle.Radius;
		}
		// If a new shape is added, this method must be modified
		throw new ArgumentException("Unknown shape");
	}
}
public class Rectangle {
	public double Width { get; set; }
	public double Height { get; set; }
}
public class Circle {
	public double Radius { get; set; }
}
```
*Adding new shapes requires modifying the AreaCalculator, violating the Open Closed Principle.*

### Example: Follows Open-Closed Principle
```csharp
public interface IShape {
	double Area();
}
public class Rectangle : IShape {
	public double Width { get; set; }
	public double Height { get; set; }
	public double Area() => Width * Height;
}
public class Circle : IShape {
	public double Radius { get; set; }
	public double Area() => Math.PI * Radius * Radius;
}
public class AreaCalculator {
	public double Area(IShape shape) {
		return shape.Area();
	}
}
```
*New shapes can be added by implementing IShape, without modifying AreaCalculator.*

## Liskov-Substitution Principle
*Introduced by Barbara Liskov in 1987!*

This principle states that a parent class and child class must be swappable without breaking, causing strange behaviour or errors. Another way to say this is **a child class must honour the contract of its parent, not just structurally but behaviourally**.


A subclass must not:
- throw unexpected exceptions,
- remove behaviour a base class guarantees,
- change expected behaviour.

Essentially, code that depends on the base class should not need to change when a subclass is introduced.

> Liskov-Substitution principle can be tied to **Inheritance** and **Polymorphism**.

### Example: Violates Liskov Substitution Principle
```csharp
public class Bird {
    public virtual void Fly() {
        // Fly logic
    }
}
public class Sparrow : Bird {
    public override void Fly() {
        // Fly
    }
}
public class Ostrich : Bird {
    public override void Fly() {
        throw new NotSupportedException("Ostriches can't fly!");
    }
}
```
*Ostrich inherits from Bird, but throws an exception for Fly, violating the contract expected by users of Bird.*

```csharp
public class Bird {
	public virtual void Move() {
		// Move logic
	}
}
public class Sparrow : Bird {
	public override void Move() {
		Console.WriteLine("Flying");
	}
}
public class Ostrich : Bird {
	public override void Move() {
		Console.WriteLine("Walking");
	}
}
```
*Now, each subclass provides its own valid implementation of Move, so substituting subclasses will not break expected behaviour.*

## Interface Segregation

This principle states that clients should not be forced to depend on methods they do not use. In other words, **do not make classes implement things they do not need**.

**Large interfaces create:**
- fragile systems,
- useless dependencies,
- unnecessary coupling,
- breaking changes.

> Interface Segregation can be tied to **Abstraction**, **Encapsulation** and **Cohesion**.

### Fat Interface
- has many unrelated methods,
- represents multiple responsibilities,
- forces clients to implement things they don't need.

```csharp
public interface IMachine {
	void Print();
	void Scan();
	void Fax();
}
```
*This interface forces all implementers to provide Print, Scan, and Fax, even if they only need one.*


### Thin Interface
- small number of related methods,
- represents one clear capability,
- is highly cohesive.

```csharp
public interface IPrinter {
	void Print();
}
```
*This interface is focused and only requires implementers to provide Print functionality.*

## Dependency Inversion

This principle states that high-level modules should not depend on low-level modules. Instead, they should both depend on abstractions.

Abstractions should not depend on implementation details, but implementation details should depend on abstractions.

For example, we want to go from this, where the high-level depends on the low-level:
```plaintext
CalculateArea → Circle
```
to this, where high-level and low-level depend on an abstraction:
```plaintext
CalculateArea → IShape ← Circle
```
The dependency is now **inverted upwards** for the low-level module. With this, you are able to swap, test, etc.

> Dependency Inversion can be tied to **Abstraction**, **Composition** and **Polymorphism**.

### Example: Violates Dependency Inversion Principle
```csharp
public class Circle {
    public double Radius { get; set; }
}
public class AreaCalculator {
    public double Area(Circle circle) {
        return Math.PI * circle.Radius * circle.Radius;
    }
}
```
*AreaCalculator depends directly on the concrete Circle class, so it cannot work with other shapes without modification.*

### Example: Follows Dependency Inversion Principle
```csharp
public interface IShape {
    double Area();
}
public class Circle : IShape {
    public double Radius { get; set; }
    public double Area() => Math.PI * Radius * Radius;
}
public class AreaCalculator {
    public double Area(IShape shape) {
        return shape.Area();
    }
}
```
*AreaCalculator depends on the abstraction IShape, so it can work with any shape that implements IShape.*