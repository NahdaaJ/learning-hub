# Object Oriented Programming
## What is OOP?
- A computer programming model that organises software design around data (objects).
- Focuses on the objects developers want to manipulate as opposed to the logic to manipulate them.
- Has 4 pillar concepts: **encapsulation, abstraction, inheritance, polymorphism**.

### Pro's and Con's
Good For: 
- large, complex, projects
- actively maintained, actively updated projects
- when the project is data/thing-based
- when you are modelling stable identities/long-lived objects that interact with each other
- e.g. budget tracker project

Bad For:
 - when you are processing data step by step
 - no storage of data
 - project is flow-based
 - e.g. CSV to JSON outputter

### Generic Structure

`Object` - Data type, instance of a class with stored data.
`Class` - Blueprint of data type.
`Methods` - Functions an object can perform.
`Attributes` - Represent the 'state' of an object, i.e. data stored in the object.

## Encapsulation
Encapsulation is the practice of restricting direct access to an object's internal state. Interaction must be done through controlled methods or properties. This is so the internal state of an object cannot be broken or misused.

Encapsulation is like a **safety layer**, protecting internal state and enforcing rules.

```csharp
public class BankAccount
{
    private decimal _balance;  // nobody outside can touch this directly

    public void Deposit(decimal amount)
    {
        if (amount <= 0) // validation, no value below 0
            throw new ArgumentException("Invalid amount");

        _balance += amount;
    }

    public decimal Balance
    {
        get { return _balance; }
    }
}
```
Encapsulation can also be implemented using **constructors**. Constructors:
- ensure the object is valid at creation,
- prevent partially initialised objects,
- enforce required dependencies.

## Abstraction
Abstraction defines a contract that specifies what an object can do. Code that depends on the abstraction doesn't care about the implementation, just what the object is able to do. This reduces coupling and allows new implementations.

```csharp
public interface IShape
{
    double CalculateArea();
    double CalculatePerimeter();
}

//------------------------------------------------------------------------
public class Circle : IShape // Circle inherits from IShape, 
{
    private double _radius;

    public Circle(double radius)
    {
        _radius = radius;
    }

    public double CalculateArea()
    {
        return Math.PI * _radius * _radius;
    }

    public double CalculatePerimeter()
    {
        return 2 * Math.PI * _radius;
    }

    public double CalculateDiameter()
    {
        return 2 * _radius;
    }
}

// ----------------------------------------------------------------------
public class ShapePrinter // does NOT care about implementation
{
    public void PrintShapeInfo(IShape shape) // only knows IShape and its capabilities
    {
        Console.WriteLine($"Area: {shape.CalculateArea()}");
        Console.WriteLine($"Perimeter: {shape.CalculatePerimeter()}");
    }
}
// ----------------------------------------------------------------------
var circle = new Circle(5); //will use methods from circle such as diameter
IShape circle2 = new Circle(5); // will only use the methods available in IShape
var rectangle = new Rectangle(4, 6);

// circle.CalculateDiameter works
// circle2.CalculateDiameter DOESN'T work

var printer = new ShapePrinter(); 

printer.PrintShapeInfo(circle); // doesn't care whether circle or rectangle is passed in
printer.PrintShapeInfo(rectangle);
```
Abstraction is done by utilising interfaces and abstract classes.

### Interfaces
"You MUST be able to do this" - similar capability.

Contains:
 - method signatures
 - properties
 - events

Pure capability contract (methods).
A class can implement multiple interfaces.
> examples: IRepository, ILogger

### Abstract Classes
"You are this type of thing" - shared state + logic
Defines a base type with shared behaviour

Contains:
- fields
- contructors
- fully implemented methods
- abstract methods (methods without implementation)

A class can only implement one abstract class.
> examples: animal (cat, dog), shape (circle, rectangle
)

### Abstraction vs Implementation
Abstraction - "Character can attack" 
Implementation - "Character casts a fireball"

## Inheritance
Inheritance is the practice of child classes reusing and extended a parent class.
"Is-a" relationship, for example, circle is a shape, toyota is a car.
```csharp
public class Animal
{
    public string Name { get; set; }

    public void Eat()
    {
        Console.WriteLine("Eating...");
    }
}

public class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine("Woof!");
    }
}
```

### Pro's and Con's
Good for:
- code reuse
- shared behaviour
- polymorphism
- strong 'is-a' relationship

Bad for:
- no strong 'is-a' relationship
- optional behaviour
- swappable implementation
- capabilities that may apply to unrelated types

### Composition
A class is built using other classes instead of directly inheriting from them.
Instead of stacking vertically, you plug pieces together horizontally.

```csharp
public class Engine
{
    public void Start()
    {
        Console.WriteLine("Engine starting...");
    }
}

public class Car
{
    private Engine _engine; // Car USES engine

    public Car()
    {
        _engine = new Engine();
    }

    public void Drive()
    {
        _engine.Start();
        Console.WriteLine("Driving...");
    }
}
```

Good for:
- avoiding inheritance hell
- runtime flexibility
- loose coupling
- changing behaviour
- swappable implementations
- no strong "is-a" relationship
- following SOLID principles


#### Dependency Injection, Coupling and Cohesion
`Dependency Injection`:
- common way to implement composition
- the things a class needs are created externally, then plugged into the class
- makes mocking these external things easier for tests
- solves tight coupling
- implements **inversion of control (IoC)** where, instead of classes controlling what they create, external sources create dependencies and pass them in.

`Coupling` - how dependent classes are on each other.
High coupling - bad
Low coupling - good

`Cohesion` - how focused a class is
High cohesion - good
Low cohesion - bad

High cohesion naturally leads to low coupling.

### Inheritance vs Composition
Inheritance - you **ARE** this thing (Toyota IS a car)
Composition - you **HAVE** this thing (a car has an engine)

Composition is the better default, as it enables loose coupling and flexibility. Inheritance should be used if there is a STRONG "is-a" relationship.

## Polymorphism
Polymorphism is the ability to treat different objects as the same type and call the same methods but get different behaviour.

```csharp
public interface IAnimal
{
    void Speak();
}

public class Dog : IAnimal
{
    public void Speak() => Console.WriteLine("Woof!");
}

public class Cat : IAnimal
{
    public void Speak() => Console.WriteLine("Meow!");
}

// Polymorphism in action
var animals = new List<IAnimal> { new Dog(), new Cat() };
foreach (var animal in animals)
{
    animal.Speak(); // Output depends on the actual type
}
```

There are two types of polymorphism: **compile-time polymorphism** and **runtime polymorphism**.

### Compile-Time Polymorphism
This is implemented using method overloading, where the same method can be called but with different parameters.

```csharp
public class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }

    public double Add(double a, double b)
    {
        return a + b;
    }
}

// Usage:
var calc = new Calculator();
Console.WriteLine(calc.Add(2, 3));      // Outputs 5
Console.WriteLine(calc.Add(2.5, 3.1));  // Outputs 5.6
```

### Runtime Polymorphism
This is implemented by the child class overriding methods from its parent class.

```csharp
public class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("Animal speaks");
    }
}

public class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Woof!");
    }
}

// Usage:
Animal myAnimal = new Dog();
myAnimal.Speak(); // Outputs: Woof!
```