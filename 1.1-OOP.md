# Object Oreinted Programming
## What is OOP?
- A computer programming model that organises software design around data (objects).
- Focuses on the objects devs want to manipulate as opposed to the logic to manipulate them.
- Has 4 pillar concepts: **encapsulation, abstraction, inheritance, polymorphism**.

### Pro's and Con's
Good For: 
- large, complex, projects
- actively maintained, actively updated projects
- whn the project is data/thing-based
- when you are modelling stable identities/long-lived objects that interact with eachother
- e.g. budget tracker project

Bad For:
 - when you are processing data step by step
 - no storage of data
 - project is flow based
 - e.g. CSV to JSON outputter

### Generic Structure

`Object` - Data type, instance of a class with stored data.
`Class` - Blueprint of data type.
`Methods` - Functions an object can perform.
`Attributes` - Represent the 'state' of an object, i.e. data stored in the object.

## Encapsulation
Encapsulatin is the practice of restricting direct access tp an objects internal state. Interaction must be done through controlled methods or properties. This is so the internal state of an object cannot be broken or misused.

Encapsulation is like a **safety layer**, protecting internal state and enforcing rules.

```csharp
public class BankAccount
{
    private decimal _balance;  // nobody outside can touch this directly

    public void Deposit(decimal amount)
    {
        if (amount <= 0) // validation, no value below 0
            throw new ArgumentException("Invalid amount");

        _balance += amount;
    }

    public decimal Balance
    {
        get { return _balance; }
    }
}
```

## Abstraction
Abstraction defines a contract that specifies what an object can do. Code that depends on the abstraction doesn't care about the implementation, just what the object is able to do. This reduces coupling and allows new implementation.

```csharp
public interface IShape
{
    double CalculateArea();
    double CalculatePerimeter();
}

//------------------------------------------------------------------------
public class Circle : IShape // Circle inherits from IShape, 
{
    private double _radius;

    public Circle(double radius)
    {
        _radius = radius;
    }

    public double CalculateArea()
    {
        return Math.PI * _radius * _radius;
    }

    public double CalculatePerimeter()
    {
        return 2 * Math.PI * _radius;
    }

    public double CalculateDiameter()
    {
        return 2 * _radius;
    }
}

// ----------------------------------------------------------------------
public class ShapePrinter // does NOT care about implementation
{
    public void PrintShapeInfo(IShape shape) // only knows IShape and its capabilities
    {
        Console.WriteLine($"Area: {shape.CalculateArea()}");
        Console.WriteLine($"Perimeter: {shape.CalculatePerimeter()}");
    }
}
// ----------------------------------------------------------------------
var circle = new Circle(5); //will use methods from circle such as diameter
IShape circle2 = new Circle(5); // will only use the methods available in IShape
var rectangle = new Rectangle(4, 6);

// circle.CalculateDiameter works
// circle2.CalculateDiameter DOESN'T work

var printer = new ShapePrinter(); 

printer.PrintShapeInfo(circle); // doesn't care whether circle or rectangle is passed in
printer.PrintShapeInfo(rectangle);
```
Abstraction is done by utilising interfaces and abstract classes.

### Interfaces
"You MUST be able to do this" - similar capability.

Contains:
 - method signatures
 - properties
 - events

Pure capability contract (methods).
A class can implement multiple interfaces.
> examples: IRepository, ILogger

### Abstract Classes
"You are this type of thing" - shared state + logic
Defines a base type with shared behaviour

Contains:
- fields
- contructors
- fully implemented methods
- abstract methods (methods without implementation)

A class can only implement one abstract class.
> examples: animal (cat, dog), shape (circle, rectangle
)

### Abstraction vs Implementation
Abstraction - "Character can attack" 
Implementation - "Character casts a fireball"

## Inheritance
Inheritance is the practice of child classes reusing and extended a parent class.
"Is-a" relationship, for example, circle is a shape, toyota is a car.
```csharp
public class Animal
{
    public string Name { get; set; }

    public void Eat()
    {
        Console.WriteLine("Eating...");
    }
}

public class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine("Woof!");
    }
}
```

### Pro's and Con's
Good for:
- code reuse
- shared behaviour
- polymorphism
- strong 'is-a' relationship

Bad for:
- no strong 'is-a' relationship
- optional behaviour
- swappable implementation
- capabilities that may apply to unrelated types

### Composition
A class is vuilt using other classes instead of directly inheriting from them.
Instead of stacking vertically, you plug peices together horizontally.

```csharp
public class Engine
{
    public void Start()
    {
        Console.WriteLine("Engine starting...");
    }
}

public class Car
{
    private Engine _engine; // Car USES engine

    public Car()
    {
        _engine = new Engine();
    }

    public void Drive()
    {
        _engine.Start();
        Console.WriteLine("Driving...");
    }
}
```

Good for:
- avoiding inheritance hell
- runtime flexibility
- loose coupling
- changing behaviour
- swappable implementations
- no strong "is-a" relationship
- following SOLID principles

`Dependency Injection`:
- common way to implement composition
- the things a class needs is created externally, then plugged into the class
- makes mocking these external things easier for tests
- solves tight coupling

### Inheritance vs Composition
Inheritance - you **ARE** this thing (Toyota IS a car)
Composition - you **HAVE** this thing (a car has an engine)

Composition is the better default, as it enables loose coupling and flexibility. Inheritance should be used if there is a STRONG "is-a" relationship.